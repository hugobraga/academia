Documentação do QoSPM
Autor: Hugo Braga
Última modificação: 12/12/08


UTILIZAÇÃO DO QOSPM:
1 - Para utilizar o QoSPM, inicialmente deve-se alterar os valores do arquivo conf.h. Este arquivo define os valores de configuração do QoSPM. As seguintes informações devem ser fornecidas:
	1.1 - Deve-se informar se o computador hospeda um modulo do QoSP, do QoSPA ou ambos. 
	1.2 - Deve-se configurar os valores das portas de comunicação utilizadas pelos componentes do QoSPM.
	1.3 - Deve-se também definir a periodicidade em que o detector de falhas do QoSP (no contexto do QoSPM) deve executar. Além disso, deve-se também definir o intervalo de tempo no qual um canal deverá ser escutado para verificar se ocorreu troca de mensagens, quando uma verificação de canal (equivale à função verifyChannel da API do QoS Provider) foi executada. É importante observar que este valor está sendo configurado de forma estática, mas possivelmente, este valor deverá ser informado pelo modelo HA. Caso necessite fazer tal alteração, o valor deste período pode ser passado como parâmetro para a função qospM_init, e uma variável global (ou local caso seja definida no contexto de uma classe) deverá ser utilizada para armazenar tal valor, sendo que a utilização da macro que define de forma estática este valor deverá ser substituída pela variável. Ambos os valores citados neste tópico só são importantes caso o computador esteja hospedando um módulo do QoSP.
	1.4 - Deve-se definir o nome da classe que recebe o serviço expresso nos roteadores cisco, além de definir a community string utilizada para trocar mensagens SNMP com os roteadores cisco. Ambos os valores citados neste tópico só são importantes caso o computador esteja hospedando um módulo do QoSPA.

2 - O QoSPM deve ser inicializado antes de sua utilização. Para isso, deve-se utilizar a função qospM_init definida no arquivo qospm_init.h. O comentário acerca dos parâmetros desta função está no arquivo qospm_init.c.

3 - A comunicação com o QoSPM se dá através das funções definidas no arquivo qospm_interface.h. Antes de utilizar as funções que fazem parte da API do QoS Provider e que compõem o QoSPM (a função QoS e a função verifyChannel), algumas informações devem ser passadas para o QoSPM. Tais informações são as seguintes:
	3.1 - Um roteador que faz parte de um canal de comunicação gerenciado pelo QoSP local deve ter sua existência notificada. Deve-se utilizar a função notifyNewRouter.
	3.2 - Um canal de comunicação gerenciado pelo QoSP local deve ter sua existência notificada. Deve-se utilizar a função notifyNewChannel. Por padrão, este canal é UNTIMELY.
	3.3 - Para informar que um roteador faz parte de um canal de comunicação, deve-se utilizar a função insertRouterInChannel.
	3.4 - Quando um canal tiver sua QoS negociada e este passar a ser um canal TIMELY, deve-se utilizar a função notifyTimelyChannel para notificar tal alteração.
	3.5 - Quando um canal tiver sua QoS alterada para UNTIMELY, deve-se utilizar a função notifyUntimelyChannel.
Depois de passada tais informações (quando necessário), as funções qos e verifyChannel podem ser utilizadas.

4 - Para enviar e receber mensagens através dos canais de comunicação gerenciados pelo QoS Provider, deve-se utilizar as funções qosp_sendmsg e qosp_recvmsg definidas em qospm_interface.h. Tais funções possuem as mesmas assinaturas das funções sendmsg e recvmsg da API de comunicação em redes do Linux, exceto pela adição de um novo parâmetro que corresponde ao descritor do canal.

5 - Quando percebe-se que a QoS de um ou mais canais de comunicação foi alterada (degradada), os processos que fazem parte destes canais e que executam no mesmo host do QoSP que percebeu a degradação (observe que cada canal é formado por dois processos, sendo que cada QoSP só precisa se preocupar em notificar a falha do processo que se localiza em seu host, visto que o agente cujo roteador teve sua QoS degradada notificará o outro módulo do QoSP, que está localizado no mesmo host do outro processo do canal, sobre a degradação. Sendo assim, cada módulo do QoSP só precisará resolver seu problema localmente) devem ser notificados de tal degradação. Quando a função QoS (ou verifyChannel) é executada e a degradação ocorre, esta é descoberta através do retorno da função. Mas quando não há execução desta função, a tese do Professor Gorender especifica que a degradação deve ser notificada através do envio da mensagem changeqos. Isto não está implementado, visto que ainda não foi discutida como será a comunicação assíncrona (aquela em que não há uma solicitação explícita por parte do processo para obter a informação) com os processos. Existem diversas maneiras em que a comunicação inter-processo (IPC) pode ocorrer no linux tais como: memória compartilhada, pipes (canais bidirecionais) e sinais. Dependendo da forma como os processos do sistema distribuído vão ser implementados, escolhe-se uma dessas maneiras na hora de implementar o algoritmo do processo distribuído. Além disso, é necessário alterar o código do QoSPM, mas especificadamente o código da função notifyChannelsDegrad_MA definida no arquivo monitoring.c, levando em consideração a forma adotada para comunicação inter-processo. O novo código deve ser inserido na parte da função demarcada pelo comentário /***URGENTE**/, sendo que cada processo local dos canais cuja QoS foi degradada deve ser notificado. Possivelmente quando a existência de um novo canal de comunicação é notificada (ver Item 3) ou a alteração da QoS do canal para TIMELY é notificada (ver Item 3), uma nova informação relativa ao processo do canal local ao QoSP deve ser passada como parâmetro, tal como um descritor de um pipe ou o tipo de sinal a ser enviado, dependendo da forma como foi implementada a comunicação inter-processo. Esta informação seria então utilizada dentro da função notifyChannelsDegrad_MA para notificar os processos de forma assíncrona sobre a degradação.


OBSERVAÇÕES:
1 - Caso a função qos e verifyChannel sejam chamadas para colher a QoS de um canal de comunicação TIMELY, o processo que executa a chamada desta função deve ser um processo de tempo real, ou seja, deve estar executando como uma tarefa do Xenomai.
